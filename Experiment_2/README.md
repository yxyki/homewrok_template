# 动态规划算法实验报告

## 学号：20201060335

## $\color{#0099ff}{实验2.1 动态规划算法的实现与时间复杂度测试}$

## 实验目的

编程实现经典的动态规划算法，理解动态规划算法设计的基本思想、程序实现的相关技巧，加深对动态规划算法设计与分析思想的理解。通过程序的执行时间测试结果，与理论上的时间复杂度结论进行对比、分析和验证。

## 实验原理

* **动态规划算法的基本思想**  
动态规划是一种在数学和计算机科学中使用的、用于求解包含重叠子问题的最优化问题的有效方法。其基本思想是：将原问题分解为相似的子问题，在求解的过程中通过子问题的解描述并求出原问题的解。动态规划的思想是多种算法的基础，被广泛应用于计算机科学和工程领域，在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题，为了避免多次解决这些子问题，它们的结果都逐渐被计算并保存，从小规模的子问题直到整个问题都被解决。因此，动态规划对每一子问题只做一次计算，具有较高的效率。  

* **测试算法**  

```C
KnapsackDP ({w1, w2, …, wn}, {v1, v2, …, vn}, C) 
  for i=0 to n do 
    m[i,0]=0 
  end for 
  for j=0 to C do 
    m[0,j]=0 
  end for 
  for i=1 to n do 
    for j=1 to C do
      m[i,j]=m[i-1,j] 
      if wi<=j then 
        m[i,j]=max{m[i,j],m[i-1,j-wi]+vi} 
      end if 
    end for 
  end for 
return m[n,C]
```
算法的时间复杂度为 *O(nC)*。

## 实验输入数据集

实验数据包括**物品的个数**以及**背包的容量**，该部分由用户输入；物品的**价值**与**质量**由随机数生成算法或者用户手动输入数据确定。

## 实验内容

编程实现以上求解 0-1 背包问题的动态规划算法，并通过手动设置、生成随机数获得实验数据。记录随着输入规模增加算法的执行时间，分析并以图形方式展现增长率；测试、验证、对比算法的时间复杂度。  

(1) 编程实现以上算法，并进行测试，保证程序正确无误。其中，分别在程序开始和结束处设置记录系统当前时间的变量、用于计算程序执行的时间（以毫秒(ms)作为程序执行时间的计数单位）。  
(2) 测试 C 值不变的情形下随着 n 增加、程序执行时间增加的趋势。对于C=200、400、800、2000 这四种情形，分别使用 1.1 节中的随机数生成算法生成n个随机数作为n个物品的重量，再生成n个随机数作为n个物品的价值（n=10, 20, 40, 100, 200, 400, 800, 2000）。对于每个 C 值,记录随着 n 增加程序的执行时间，并使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成各不同 C 值情形下程序执行时间的对比曲线图（4条折线）。  
(3) 与理论上的时间复杂度结论进行对比分析，完成实验报告。  

**代码链接**  
[Knapsack.c(0-1背包问题)](https://github.com/yxyki/homewrok_template/blob/main/Experiment_2/Knapsack.c)

## 实验预期结果与实际结果
+ **实验预期结果** :总共有n个物品，背包容量为C，可以得出该算法的时间复杂度为*O(nC)*.

* **实验过程及实验结果**  
此次实验结果展示仅为n=10,C=200\400\800\2000的情形。

（C版，n=10,C=200）
```bash
gitpod /workspace/homewrok_template/Experiment_2 (main) $ gcc -o Knapsack.exe Knapsack.c
gitpod /workspace/homewrok_template/Experiment_2 (main) $ ./Knapsack.exe
请输入物品的个数以及物品最大价值:10 50
请输入背包容量:200
1.手动输入数据
2.生成随机数
2
第1个物品的重量为19,价值为19
第2个物品的重量为188,价值为38
第3个物品的重量为15,价值为15
第4个物品的重量为194,价值为44
第5个物品的重量为81,价值为31
第6个物品的重量为115,价值为15
第7个物品的重量为75,价值为25
第8个物品的重量为160,价值为10
第9个物品的重量为7,价值为7
第10个物品的重量为59,价值为9
最大价值为:97
程序的时间为38ms
```

（C版,n=10,C=400）
```bash
gitpod /workspace/homewrok_template/Experiment_2 (main) $ ./Knapsack.exe
请输入物品的个数以及物品最大价值:10 100
请输入背包容量:400
1.手动输入数据
2.生成随机数
2
第1个物品的重量为98,价值为98
第2个物品的重量为286,价值为86
第3个物品的重量为14,价值为14
第4个物品的重量为165,价值为65
第5个物品的重量为248,价值为48
第6个物品的重量为161,价值为61
第7个物品的重量为21,价值为21
第8个物品的重量为10,价值为10
第9个物品的重量为44,价值为44
第10个物品的重量为164,价值为64
最大价值为:252
程序的时间为56ms
```

（C版，n=10,C=800）
```bash
gitpod /workspace/homewrok_template/Experiment_2 (main) $ ./Knapsack.exe
请输入物品的个数以及物品最大价值:10 100
请输入背包容量:800
1.手动输入数据
2.生成随机数
2
第1个物品的重量为273,价值为73
第2个物品的重量为728,价值为28
第3个物品的重量为178,价值为78
第4个物品的重量为209,价值为9
第5个物品的重量为87,价值为87
第6个物品的重量为798,价值为98
第7个物品的重量为568,价值为68
第8个物品的重量为113,价值为13
第9个物品的重量为457,价值为57
第10个物品的重量为546,价值为46
最大价值为:251
程序的时间为80ms
```  

(C版,n=10,C=2000)  
```bash
gitpod /workspace/homewrok_template/Experiment_2 (main) $ ./Knapsack.exe
请输入物品的个数以及物品最大价值:10 150
请输入背包容量:2000
1.手动输入数据
2.生成随机数
2
第1个物品的重量为794,价值为44
第2个物品的重量为1122,价值为72
第3个物品的重量为1437,价值为87
第4个物品的重量为879,价值为79
第5个物品的重量为1859,价值为59
第6个物品的重量为1573,价值为73
第7个物品的重量为1370,价值为120
第8个物品的重量为1332,价值为32
第9个物品的重量为238,价值为88
第10个物品的重量为1431,价值为31
最大价值为:211
程序的时间为124ms
```   
实验记录表格如下：  
背包容量\物体数量|10|20|40|100|200|400|800|2000
-|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
200|32|37|65|158|246|496|855|2140
400|56|64|98|367|454|909|1760|4467
800|80|94|191|469|876|1796|3333|8383
2000|124|220|497|1419|2114|4222|8838|27616  

由matlab软件画出背包容量C分别等于200、400、800和1000时，程序执行时间随着物品数量的增加而改变的曲线图如下所示：  
![](/Experiment_2/img/exp2_1.png)  

>由曲线图可知，实际运行结果大致为一条直线，与理论的时间复杂度*O(nC)* 基本一致。而通过本次实验，让我对动态规划算法进一步地加深了认识。  

## $\color{#0099ff}{实验 2.2 动态规划算法的适应性测试}$  

## 实验目的

对于同一问题，编程实现其分治算法和动态规划算法，通过对比分析，理解动态规划算法的适用情形。通过程序的执行时间测试结果，与理论结论进行对比、分析和验证。

## 实验原理

* **分治算法与动态规划算法的对比：针对子问题是否重叠**  
虽然很多问题均可分解为子问题、动态规划和分治算法都是通过子问题的解决来获得原问题的解。然而，分治算法适用于子问题不重叠（即相互独立）的情形，对于子问题重叠的情形分治法具有较高的时间复杂度，动态规划是针对这类情形的有效算法。  

* **测试算法**  
斐波纳契数列在现代物理、准晶体结构、化学等领域都有直接的应用。斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、……，这个数列从第三项开始，每一项都等于前两项之和，即：  
![2](http://latex.codecogs.com/svg.latex?f(n)={\begin{cases}1&n=1,2\\\\f(n-1)+f(n-2)&n\geq3\\\\\end{cases})  
直观地，斐波纳契数列可递归地得到，算法如下：  
```C
DAC_f(n) 
  if(n==1) or (n==2) then 
    return 1 
  else 
    return f(n-1)+f(n-2) 
  end if
```  
通过理论分析已经得出结论：以上递归算法随着 n 增大有指数计算时间。对于 n 的多项式个数的子问题，显然指数计算时间是不现实的。基于动态规划算法可高效地求解 Fibonacci 数问题，算法如下：  
```C
DP_f(n) 
  Initialize f[1..n] 
  for i=1 to n do 
    if(i==1) or (i==2) then 
      f[i]=1 
    else 
      f[i]=f[i-1]+f[i-2] 
    end if 
  end for 
  return f[n]
```  
算法的时间复杂度为 *O(n)*。

## 实验输入数据集

不同的n值:5,10,15,20,25,30  

## 实验内容

编程实现以上求斐波纳契数的分治算法和动态规划算法。对于每个算法，记录随着斐波纳契数数列大小增加基本操作的执行次数，分析并以图形方式展现增长率；对比这两个算法，随着数列大小增加算法增长率的变化趋势；测试、验证、对比理论结论。  

(1) “加法”是以上两个斐波纳契数算法的基本操作。编程实现以上 DAC_f和 DP_f 算法，并进行测试，在其中设置加法执行次数的计数器变量。  
(2) 分别测试不同 n 值（n=5, 10, 15, 20, 25, 30）情形下 DAC_f 和 DP_f 算法的加法次数，记录加法次数，并使用 MS Excel、Matlab 或 Origin 等图表绘制工具生成各不同 n 值情形下以上两个算法加法次数的对比曲线图（2 条折线）。  
(3) 与两个算法时间复杂度的理论结论进行对比分析，总结分治与动态规划算法的适用条件和特点，完成实验报告。  

**代码链接**  
[Fibonacci.c(斐波那契数列)](https://github.com/yxyki/homewrok_template/blob/main/Experiment_2/Fibonacci.c)

## 实验预期结果与实际结果
+ **实验预期结果**：使用分治法计算斐波那契数列时，时间复杂度为指数级别，而使用动态规划计算，时间复杂度为线性级别*O(n)*。  

+ **实验过程及实验结果**  

（C版,n=10）
```bash
gitpod /workspace/homewrok_template/Experiment_2 (main) $ ./Fibonacci.exe
请输入n的值:5
分治法:n=5时,结果为:5
加法次数为:4
动态规划法:n=5时,结果为:5
加法次数为:3
```

（C版,n=20）  
```bash
gitpod /workspace/homewrok_template/Experiment_2 (main) $ ./Fibonacci.exe
请输入n的值:20
分治法:n=20时,结果为:6765
加法次数为:6764
动态规划法:n=20时,结果为:6765
加法次数为:18
```

（C版,n=30）  
```bash
gitpod /workspace/homewrok_template/Experiment_2 (main) $ ./Fibonacci.exe
请输入n的值:30
分治法:n=30时,结果为:832040
加法次数为:832039
动态规划法:n=30时,结果为:832040
加法次数为:28
```  
实验数据记录如下表所示：  
排序|5|10|15|20|25|30
-|:-:|:-:|:-:|:-:|:-:|:-:
分治法|4|54|609|6764|75024|832037
动态规划|3|8|13|18|23|28  

由实验结果，根据matlab软件，画出的加法次数对比曲线图如下所示：  
![](/Experiment_2/img/exp2_2.png)  
动态规划算法的加法次数如下：  
![](/Experiment_2/img/exp2_3.png)  

> 由图可知，使用分治法的加法次数接近于指数级别，而使用动态规划则是线性级别，与理论数据保持一致。本次实验的斐波那契数列每个子问题都不是独立的，有重叠部分，由此可以说明分治法适用于子问题不重叠的问题，当子问题重叠时，递归调用会使用很多次，导致操作次数过多，从而时间复杂度也过高。而动态规划针对重叠子问题有着很好的性能，能大大降低时间复杂度。